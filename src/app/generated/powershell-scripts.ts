/* tslint:disable */
/**
 * @file Source code generated by gulp-ps-code.
 * @version 1.1
 */
export module PowerShellScripts {
    'use strict'

    export const module = '{!company-name}.{!module-name}';
    export const Get_Error = {
        command: 'Get-Error',
        script: "##Get-Error##:Get-Error.ps1\nParam([int]$wait)\nsleep $wait\nwrite-progress -Activity \"running\" -PercentComplete 50\nwrite-error \"=== Error Error Error === ($wait)\"\n"
    }
    export const Get_Exception = {
        command: 'Get-Exception',
        script: "##Get-Exception##:Get-Exception.ps1\nParam([int]$wait)\nsleep $wait\nwrite-progress -Activity \"running\" -PercentComplete 50\nthrow \"=== Exception Exception Exception === ($wait)\"\n"
    }
    export const Get_Process = {
        command: 'Get-Process',
        script: "##Get-Process##:Get-Process.ps1\nget-process\n"
    }
    export const Get_Service = {
        command: 'Get-Service',
        script: "##Get-Service##:Get-Service.ps1\nParam([string]$name)\nget-service -Name $name\n"
    }
    export const Get_WinRmState = {
        command: 'Get-WinRmState',
        script: "##Get-WinRmState##:Get-WinRmState.ps1\n1..30 | foreach {\nsleep 2\n$p = [math]::floor($_/30 * 100)\nwrite-progress -Activity \"running\" -PercentComplete $p\nget-service winrm\n}\n"
    }
    export const admin_api_util = {
        command: 'admin_api_util',
        script: "##admin_api_util##:admin_api_util.ps1\n[CmdletBinding()]\nparam(\n[Parameter(Mandatory=$true)]\n[ValidateSet(\u0027install\u0027, \u0027ensure\u0027)]\n[string]\n$command,\n[string]\n$adminAPILocation,\n[string]\n$dotnetCoreLocation,\n[string]\n$sessionId,\n[string]\n$appName = \"Microsoft IIS Administration\",\n[Version]\n$appMinVersion,\n[string]\n$serviceName = \"Microsoft IIS Administration\",\n[string]\n$iisAdminOwners = \"IIS Administration API Owners\",\n[string]\n$apiHost = \"https://localhost:55539\"\n)\n$ErrorActionPreference = \"Stop\"\n$install = $command -eq \u0027install\u0027\nfunction VerifySource([string] $source) {\nif (Test-Path -IsValid $source) {\nreturn \"file\"\n}\nif ([Uri]::TryCreate($source, [UriKind]::Absolute, [ref]$null)) {\nreturn \"uri\"\n}\nthrow \"Invalid install source $source\"\n}\n$dotnetCoreInstallType = $null\n$iisAdminInstallType = $null\nif ($install) {\nif ($dotnetCoreLocation) {\n$dotnetCoreInstallType = VerifySource $dotnetCoreLocation\n}\nif (!$adminAPILocation) {\nthrow \"Missing admin API installer location for install command\"\n}\n$iisAdminInstallType = VerifySource $adminAPILocation\n}\n$verbose = $PSBoundParameters[\u0027verbose\u0027]\nif ($verbose) {\n$logDir = Join-Path $env:UserProfile \u0027wac-iis-logs\u0027\nif (!(Test-Path $logDir)) {\nmkdir $logDir | Out-Null\n}\n$timestamp = Get-Date -Format \"yyyyMMddTHHmmssffffZ\"\n$logFile = Join-Path $logDir \"admin_api_util-${timestamp}-${sessionId}.log\"\n}\nfunction LogVerbose([string] $msg) {\n$msg = \"[$(Get-Date -Format \"\"yyyy/MM/dd HH:mm:ss:ffff\"\")] $msg\"\nif ($verbose) {\nWrite-Verbose $msg\nAdd-Content -Value $msg -Path $logFile -Force | Out-Null\n}\n}\nfunction WaitForServerToStart($service) {\n$waitPeriod = 1\n$remainingTime = 600\nwhile (!(Get-Service $service -ErrorAction SilentlyContinue | Where-Object {$_.Status -eq \"Running\"})) {\nStart-Sleep -Seconds $waitPeriod\n$remainingTime -= $waitPeriod\nif ($remainingTime -lt 0) {\nthrow \"Timeout waiting for service to start\"\n}\n}\nLogVerbose \"Server started, time remaining ${remainingTime}...\"\n}\n$script:adminAPIInstalled = $false\nfunction InstallComponents {\nif ($dotnetCoreLocation) {\nInstall \"dotnet-core-runtime\" $dotnetCoreInstallType $dotnetCoreLocation\n}\nInstall \"iis-administration-api\" $iisAdminInstallType $adminAPILocation\nWaitForServerToStart $serviceName\n$script:adminAPIInstalled = $true\n}\nfunction Download([string] $uri, [string] $location) {\nInvoke-WebRequest $uri -OutFile $location\nLogVerbose \"Downloaded $uri to $location\"\n}\nfunction Install([string] $scenario, [string] $installType, [string] $location) {\n$installer = Join-Path $env:TEMP \"${scenario}.exe\"\nLogVerbose \"source: $location will be copied to $installer\"\nif ($installType -eq \"file\") {\nCopy-Item -Path $location -Destination $installer -Force | Out-Null\n} elseif ($installType -eq \"uri\") {\nDownload $location $installer\n} else {\nthrow \"Invalid install type $installType\"\n}\nLogVerbose \"Running $installer\"\n\u0026 $installer /s DefaultCors=false | Out-Null\n$script:groupModified = $true\nLogVerbose \"Successfully installed $scenario\"\n}\nfunction GetIISAdminAPIApp {\nreturn Get-WMIObject -Class Win32_Product | Where-Object { $_.Name -eq $appName }\n}\nfunction ThrowExpectedError($err) {\nthrow (ConvertTo-Json $err -Compress -Depth 100)\n}\nfunction EnsureMinVersion($app, $minVersion) {\n$version = [Version]::Parse($app.Version)\nif ($version -lt $minVersion) {\nThrowExpectedError @{\n\"Type\" = \"PREREQ_BELOW_MIN_VERSION\";\n\"App\" = $app.Name;\n\"Actual\" = $version.ToString();\n\"Required\" = $minVersion.ToString()\n}\n}\n}\nfunction EnsureIISAdminStarted {\ntry {\nLogVerbose \"Pinging Admin API at $apiHost\"\nInvoke-WebRequest -UseDefaultCredentials -UseBasicParsing $apiHost | Out-Null\n} catch {\nif ($_.Exception.Status -eq [System.Net.WebExceptionStatus]::ConnectFailure) {\n$service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\nif (!$service) {\nThrowExpectedError @{\n\"Type\" = \"ADMIN_API_SERVICE_NOT_FOUND\";\n\"App\" = $appName\n}\n}\nif ($service.Status -eq [System.ServiceProcess.ServiceControllerStatus]::Running) {\nThrowExpectedError @{\n\"Type\" = \"ADMIN_API_SERVICE_WRONG_ENDPOINT\";\n\"EndPoint\" = $apiHost\n}\n}\nThrowExpectedError @{\n\"Type\" = \"ADMIN_API_SERVICE_NOT_RUNNING\";\n\"Status\" = $service.Status\n}\n}\nthrow\n}\n}\nfunction GetLocalAd {\n$server = \"$env:COMPUTERNAME\"\nreturn [ADSI]\"WinNT://$server,computer\"\n}\nfunction VerifyCOMErrorCode($thrown, $code) {\nreturn ($thrown.Exception -and\n$thrown.Exception.InnerException -and\n$thrown.Exception.InnerException -is [System.Runtime.InteropServices.COMException] -and\n($thrown.Exception.InnerException.HResult -eq $code -or $thrown.Exception.InnerException.ErrorCode -eq $code))\n}\n$script:groupModified = $false\nfunction EnsureUserGroup($groupName) {\n$userAD = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name\nif ((Get-Command \"Get-LocalGroupMember\" -ErrorAction SilentlyContinue) -and\n(Get-Command \"Add-LocalGroupMember\" -ErrorAction SilentlyContinue)) {\nif (!(Get-LocalGroupMember -Group $groupName -Member $userAD -ErrorAction SilentlyContinue)) {\nAdd-LocalGroupMember -Group $groupName -Member $userAD | Out-Null\n$script:groupModified = $true\n}\n} else {\n$userPath = \u0027WinNT://\u0027 + $userAD.Replace(\"\\\", \"/\")\n$localAd = GetLocalAd\ntry {\n$group = $localAd.Children.Find($groupName, \u0027group\u0027)\n} catch {\nif (VerifyCOMErrorCode $_ 0x800708AC) {\nLogVerbose \"Re-throwing an exception that might have indicated that the group ${groupName} does not exist\"\n}\nthrow\n}\ntry {\n$group.Invoke(\u0027Add\u0027, @($userPath)) | Out-Null\n$script:groupModified = $true\n} catch {\nif (VerifyCOMErrorCode $_ 0x80070562) {\nLogVerbose \"Member ${userAD} already exists in ${groupName}\"\n} else {\nthrow\n}\n}\n}\n}\nLogVerbose \u0027Started admin_api_util...\u0027\nif ($install) {\nInstallComponents\n} else {\n$app = GetIISAdminAPIApp\nif ($app) {\nEnsureMinVersion $app $appMinVersion\n}\nEnsureIISAdminStarted\n}\nEnsureUserGroup $iisAdminOwners\nConvertTo-Json @{\n\"adminAPIInstalled\" = $script:adminAPIInstalled;\n\"apiHost\" = $apiHost;\n\"groupModified\" = $script:groupModified\n} -Compress -Depth 100\n"
    }
    export const local_http = {
        command: 'local_http',
        script: "##local_http##:local_http.ps1\n[CmdletBinding()]\nparam(\n[Parameter(Mandatory=$true)]\n[string]\n$requestBase64,\n[Parameter(Mandatory=$true)]\n[string]\n$sessionId\n)\n$ErrorActionPreference = \"Stop\"\nAdd-Type -AssemblyName System.Net.Http\n$contentEncoding = [System.Text.Encoding]::UTF8\n$verbose = $PSBoundParameters[\u0027verbose\u0027]\nif ($verbose) {\n$logDir = Join-Path $env:UserProfile \u0027wac-iis-logs\u0027\nif (!(Test-Path $logDir)) {\nmkdir $logDir | Out-Null\n}\n$timestamp = Get-Date -Format \"yyyyMMddTHHmmssffffZ\"\n$logFile = Join-Path $logDir \"local_http-${timestamp}-${sessionId}.log\"\n}\nfunction LogVerbose([string] $msg) {\n$msg = \"[$(Get-Date -Format \"\"yyyy/MM/dd HH:mm:ss:ffff\"\")] $msg\"\nif ($verbose) {\nWrite-Verbose $msg\nAdd-Content -Value $msg -Path $logFile -Force | Out-Null\n}\n}\nfunction stringify([System.Byte[]]$content) {\nif (!$content) {\nreturn $content\n}\nreturn [System.Convert]::ToBase64String($content).ToString()\n}\n$patchMethod = New-Object System.Net.Http.HttpMethod \"PATCH\"\n$requestMethods = @(\n[System.Net.Http.HttpMethod]::Get,\n[System.Net.Http.HttpMethod]::Post,\n[System.Net.Http.HttpMethod]::Put,\n[System.Net.Http.HttpMethod]::Delete,\n[System.Net.Http.HttpMethod]::Options,\n[System.Net.Http.HttpMethod]::Head,\n$patchMethod\n)\nLogVerbose \"Raw request $requestBase64\"\n$decoded = $contentEncoding.GetString([System.Convert]::FromBase64String($requestBase64))\n$reqObj = ConvertFrom-Json $decoded\nLogVerbose \"Request $decoded\"\n$httpMethod = $requestMethods[[int]$reqObj.method]\n$uriBuilder = [System.UriBuilder]$reqObj.url\n$uriBuilder.Host = \"localhost\"\n$uri = $uriBuilder.ToString()\ntry {\n$httpMsg = New-Object System.Net.Http.HttpRequestMessage -ArgumentList $httpMethod, $uri\nif ($reqObj._body) {\n$requestContent = New-Object System.Net.Http.StringContent ([string] $reqObj._body)\n$httpMsg.Content = $requestContent\n}\nforeach ($prop in $reqObj.headers | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name) {\n$headerValue = $reqObj.headers.$prop\nif (!$httpMsg.Headers.TryAddWithoutValidation($prop, $headerValue)) {\n$headerFixed = $false\nif ($httpMsg.Content) {\nif ($prop -like \"content-type\") {\n$httpMsg.Content.Headers.ContentType = New-Object System.Net.Http.Headers.MediaTypeHeaderValue $headerValue\n$headerFixed = $true\n} elseif ($prop -like \"content-range\") {\n$tokens = $prop.Split(\"/-\")\n$from = [int]::Parse(($tokens[0].Trim() -split \" \")[-1])\n$to = [int]::Parse($tokens[1].Trim())\n$length = [int]::Parse($tokens[2].Trim())\n$httpMsg.Content.Headers.ContentRange = New-Object System.Net.Http.Headers.ContentRangeHeaderValue -ArgumentList $from, $to,  $length\n$headerFixed = $true\n}\n}\nif ($headerFixed) {\nLogVerbose \"Replaced header ${prop}: ${headerValue}\"\n} else {\nLogVerbose \"Failed to add header ${prop}: ${headerValue}\"\n}\n}\n}\n$clientHandler = New-Object System.Net.Http.HttpClientHandler\n$clientHandler.UseDefaultCredentials = $true\n$client = New-Object System.Net.Http.HttpClient -ArgumentList $clientHandler\n$responseMsg = $client.SendAsync($httpMsg).GetAwaiter().GetResult()\nif ($responseMsg.Content) {\n$resContent = stringify $responseMsg.Content.ReadAsByteArrayAsync().GetAwaiter().GetResult()\n}\n$result = ConvertTo-Json @{\n\"url\" = $responseMsg.RequestMessage.RequestUri\n\"status\" = $responseMsg.StatusCode;\n\"statusText\" = $responseMsg.ReasonPhrase;\n\"type\" = $responseMsg.Content.Headers.ContentType.MediaType;\n\"headers\" = $responseMsg.Content.Headers;\n\"body\" = $resContent\n} -Compress -Depth 100\n} finally {\nif ($responseMsg) {\n$responseMsg.Dispose()\n}\nif ($requestContent) {\n$requestContent.Dispose()\n}\nif ($httpMsg) {\n$httpMsg.Dispose()\n}\nif ($clientHandler) {\n$clientHandler.Dispose()\n}\nif ($client) {\n$client.Dispose()\n}\n}\nif ($result) {\n$result\n} else {\nthrow \"Unexpected error occured\"\n}\n"
    }
    export const start_admin_api = {
        command: 'start_admin_api',
        script: "##start_admin_api##:start_admin_api.ps1\n[CmdletBinding()]\nparam(\n[string]\n$sessionId,\n[string]\n$serviceName = \"Microsoft IIS Administration\"\n)\n$ErrorActionPreference = \"Stop\"\nfunction WaitForServerToStart($service) {\n$waitPeriod = 1\n$remainingTime = 600\nwhile (!(Get-Service $service -ErrorAction SilentlyContinue | Where-Object {$_.Status -eq \"Running\"})) {\nStart-Sleep -Seconds $waitPeriod\n$remainingTime -= $waitPeriod\nif ($remainingTime -lt 0) {\nthrow \"Timeout waiting for service to start\"\n}\n}\n}\nStart-Service -Name $serviceName\nWaitForServerToStart $serviceName\n\u0027{ \"success\": true }\u0027\n"
    }
    export const token_utils = {
        command: 'token_utils',
        script: "##token_utils##:token_utils.ps1\nParam(\n[Parameter(Mandatory=$true)]\n[string]\n$sessionId,\n[Parameter(Mandatory=$true)]\n[ValidateSet(\u0027ensure\u0027, \u0027delete\u0027)]\n[string]\n$command,\n[Parameter(Mandatory=$true)]\n[string]\n$apiHost,\n[string]\n$tokenId,\n[int]\n$tokenExpiryDays = 3\n)\n$ErrorActionPreference = \"Stop\"\n$contentEncoding = [System.Text.Encoding]::UTF8\n$tokenName = \"WAC/${sessionId}\"\n$RenewEndpoint = \"access-tokens\"\n$CreateEndpoint = \"api-keys\"\n$DeleteEndpoint = \"api-keys\"\n$verbose = $PSBoundParameters[\u0027verbose\u0027]\nif ($verbose) {\n$logDir = Join-Path $env:UserProfile \u0027wac-iis-logs\u0027\nif (!(Test-Path $logDir)) {\nmkdir $logDir | Out-Null\n}\n$timestamp = Get-Date -Format \"yyyyMMddTHHmmssffffZ\"\n$logFile = Join-Path $logDir \"token_utils-${timestamp}-${sessionId}.log\"\n}\nfunction LogVerbose([string] $msg) {\n$msg = \"[$(Get-Date -Format \"\"yyyy/MM/dd HH:mm:ss:ffff\"\")] $msg\"\nif ($verbose) {\nWrite-Verbose $msg\nAdd-Content -Value $msg -Path $logFile -Force | Out-Null\n}\n}\nfunction VerifyResponse([string] $action, [Microsoft.Powershell.Commands.WebResponseObject] $response) {\nif ($response.StatusCode -ge 300) {\n$msg = \"Invalid status code $($response.StatusCode) while performing action: $action\"\nLogVerbose $msg\nthrow $msg\n}\n}\nfunction ConvertTo-SystemLocaleDateString($date)\n{\n$culture = (Get-WinSystemLocale).name\n$cultureInfo = New-Object system.globalization.cultureinfo($culture)\nreturn (Get-date -Date $expires_on_date -Format ($cultureInfo.DateTimeFormat.ShortDatePattern))\n}\nfunction TokenRequest([string] $targetEndpoint, [string]$method, [string]$subpath, $requestBody) {\n$endpoint = \"$apiHost/security/$targetEndpoint\"\nLogVerbose \"Reaching out to endpoint $endpoint\"\n$sessionCreate = Invoke-WebRequest $endpoint -UseBasicParsing -UseDefaultCredentials -SessionVariable sess\nVerifyResponse \"Create WSRF-TOKEN on $targetEndpoint\" $sessionCreate | Out-Null\n$hTok = $sessionCreate.headers.\"XSRF-TOKEN\"\nif ($hTok -is [array]) {\n$hTok = $hTok[0]\n}\n$requestParams = @{\n\"Uri\" = $endpoint;\n\"Headers\" = @{ \u0027XSRF-TOKEN\u0027 = $htok };\n\"Method\" = $method;\n\"UseDefaultCredentials\" = $true;\n\"UseBasicParsing\" = $true;\n\"ContentType\" = \"application/json\";\n\"WebSession\" = $sess\n}\nif ($subpath) {\n$requestParams.Uri += \"/${subpath}\"\n}\nif ($requestBody) {\n$requestParams.Body = (ConvertTo-Json -Compress $requestBody)\n}\n$tokenUpsert = Invoke-WebRequest @requestParams\nVerifyResponse \"Upsert access token on $targetEndpoint\" $sessionCreate | Out-Null\nreturn $contentEncoding.GetString($tokenUpsert.Content)\n}\nif ($tokenId) {\n$existingToken = @{ \"id\" = $tokenId }\n} else {\nLogVerbose \"Creating new token\"\n$query = Invoke-WebRequest \"$apiHost/security/$CreateEndpoint\" -UseBasicParsing -UseDefaultCredentials -ContentType \"application/json\"\nVerifyResponse \"query exsiting tokens\" $query | Out-Null\n$existingToken = (ConvertFrom-Json $contentEncoding.GetString($query.Content)).api_keys | Where-Object { $_.purpose -eq $tokenName }\nLogVerbose \"New token $tokenId created\"\n}\nif ($command -eq \u0027ensure\u0027) {\nif ($existingToken) {\n$expires_on_date = (Get-Date).AddDays($tokenExpiryDays)\n$existingToken.expires_on = ConvertTo-SystemLocaleDateString $expires_on_date\n$output = TokenRequest -targetEndpoint $RenewEndpoint -method \"POST\" -requestBody @{ \"api_key\" = $existingToken }\n} else {\n$expires_on_date = (Get-Date).AddDays(14)\n$expires_on = ConvertTo-SystemLocaleDateString $expires_on_date\n$output = TokenRequest -targetEndpoint $CreateEndpoint -method \"POST\" -requestBody @{ \"expires_on\" = $expires_on; \"purpose\" = $tokenName }\n}\n} elseif ($command -eq \u0027delete\u0027) {\n$output = TokenRequest -targetEndpoint $DeleteEndpoint -method \"DELETE\" -subpath $existingToken.id\n}\n$output\n"
    }
}
